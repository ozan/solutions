#
# Test triange with some examples
#
# s0 - num of tests left to run
# s1 - address of side 1
# s2 - address of side 2
# s3 - address of side 3
# s4 - address of expected output
# s5 - value of expected output
#
# triangle must:
# - be named triangle and declared as global
# - read input integers from a0, a1 and a2
# - follow the convention of using the t0-9 registers for temporary storage
# - (if it wants to use s0-7 then it is responsible for pushing existing values to the stack then popping them back off before returning)
# - write result to v0 as:
#       0 - scalene
#       1 - isoceles
#       2 - equilateral
#       3 - invalid triangle

.data

n: .word 11
as:   .word 2, 10, 3, 4, 4, 3, 10, 5, 7, 1, 0
bs:   .word 2, 10, 4, 3, 7, 4, 11, 4, 3, 1, 0
cs:   .word 2, 10, 4, 4, 4, 5, 12, 2, 2, 3, 0
outs: .word 2,  2, 1, 1, 1, 0,  0, 0, 3, 3, 3

failmsg: .asciiz "failed for test input: "
okmsg: .asciiz "all tests passed"
comma: .asciiz ", "

.text

runner:
        lw      $s0, n
        la      $s1, as
        la      $s2, bs
        la      $s3, cs
        la      $s4, outs

run_test:
        lw      $a0, 0($s1)             # load inputs into argument registers
        lw      $a1, 0($s2)
        lw      $a2, 0($s3)

        jal     triangle                # call subroutine under test
        move    $v1, $v0                # move return value in v0 to v1 because we need v0 for syscall

        lw      $s5, 0($s4)             # read expected output from memory
        bne     $v1, $s5, exit_fail     # if expected doesn't match actual, jump to fail

        addi    $s1, $s1, 4             # move to next word in as
        addi    $s2, $s2, 4             # move to next word in bs
        addi    $s3, $s3, 4             # move to next word in cs
        addi    $s4, $s4, 4             # move to next word in output

        sub     $s0, $s0, 1             # decrement num of tests left to run
        bgt     $s0, $zero, run_test    # if more than zero tests to run, jump to run_test

exit_ok:
        la      $a0, okmsg              # put address of okmsg into a0
        li      $v0, 4                  # 4 is print string
        syscall

        li      $v0, 10                 # 10 is exit with zero status (clean exit)
        syscall

exit_fail:
        la      $a0, failmsg            # put address of failmsg into a0
        li      $v0, 4                  # 4 is print string
        syscall

        lw      $a0, 0($s1)             # set arg of syscall to input that failed the test
        li      $v0, 1                  # 1 is print int
        syscall

        la      $a0, comma             # put address of failmsg into a0
        li      $v0, 4                  # 4 is print string
        syscall

        lw      $a0, 0($s2)             # set arg of syscall to input that failed the test
        li      $v0, 1                  # 1 is print int
        syscall

        la      $a0, comma             # put address of failmsg into a0
        li      $v0, 4                  # 4 is print string
        syscall

        lw      $a0, 0($s3)             # set arg of syscall to input that failed the test
        li      $v0, 1                  # 1 is print int
        syscall

        li      $a0, 1                  # set exit code to 1
        li      $v0, 17                 # terminate with the exit code in $a0
        syscall

# # Include your implementation here if you wish to run this from the MARS GUI.
# .include "impl.mips"
